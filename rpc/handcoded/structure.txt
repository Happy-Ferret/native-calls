The structure of Native calls is given below.

There are NaClRPCModules which can be thought of as name spaces that contain layers of implementation.
These layers are shown below and explained below the diagram.


    +-------------------------------------------------------------------+
    |                           NaClRPCModule                           |
    |-------------------------------------------------------------------|
    |                                                                   |
    |                                                                   |
    |     +-------------------------------------------------------+     |
    |     |+-----------------------------------------------------+|     |
    |     || +--------------------+ Stub +----------------------+|| 1   |
    |     |+-----------------------------------------------------+|     |
    |     +-------------------------------------------------------+     |
    |                 +                      ^            ^             |
    |                 |                      |            |             |
    |                 |callRPC               |successCB   |errorCB      |
    |                 |                      |            |             |
    |                 v                      +            +             |
    |     +-------------------------------------------------------+     |
    |     |                        Runtime                        | 2   |
    |     +-------------------------------------------------------+     |
    |      +          +        +                ^           ^           |
    |      |          |        |                |handle     |           |
    |      |send      |send    |send            |Callback   |handle     |
    |      |Callback  |Error   |Request         |/handleCall|Error      |
    |      v          v        v                +           +           |
    |     +-------------------------------------------------------+     |
    |     |                        JSONRPC                        | 3   |
    |     +-------------------------------------------------------+     |
    |      +         +         +                ^                       |
    |      |         |         |                |                       |
    |      |sendRPC  |sendRPC  |sendRPC         |handleRPCCallback      |
    |      |Callback |Error    |Request         |/ handleRPCCall        |
    |      v         v         v                +                       |
    |     +-------------------------------------------------------+     |
    |     |                       Transport                       | 4   |
    |     +-------------------------------------------------------+     |
    |         +        +       +                ^                       |
    |         |        |       |                |                       |
    |         |        |       |                |                       |
    |         |on      |load   |postMessage     |handleMessage          |
    |         |        |       |                |                       |
    |         v        v       v                +                       |
    |     +-------------------------------------------------------+     |
    |     |+-----------------------------------------------------+|     |
    |     ||+-------------------+ NaClModule +------------------+|| 5   |
    |     |+-----------------------------------------------------+|     |
    |     +-------------------------------------------------------+     |
    |                                                                   |
    +-------------------------------------------------------------------+

If we have a complicated calculation that needs to be done using a native application written in C++, we write a
module for it in both C++ and JavaScript.

The JavaScript module is explained here. It consists of method stubs whose implementations are in the native code.
For example, we consider some functions that calculate some floating point arithmetic,. The module would be called
FloatingArithmetic. Inside the module, we would have some stubs: float sum(float*), float product(float*), and
float productSum(float*, float*).

Inside a method stub, which is the top layer depicted above (1), some checks are made to ensure the right types have
been passed in to the stub. Eventually, the callRPC method is called. The callRPC method is part of the Runtime library.
Continuing from our example above, we consider the sum(float*) stub. In Javascript, this would be a function that
takes in an array of Numbers and returns a float* representing their sum. But because our RPC system is asynchronous,
the function would take in another parameter, a success callback, that gets called when the function returns. So the
float sum(float*) function would look something like this:

function sum(numbers, cb){
   ...
}

This would be the JS stub, encapsulated inside the RPC Module. Somewhere inside the stub body, a call to the RPC Runtime
layer would be made that would look like this:

callRPC("sum", numbers, cb)

The RPC Runtime (2) then constructs a json-rpc object. It also generates a new ID that uniquely identifies this function
call. This ID is used to map callbacks with function calls. So when the C++ code finishes executing, the correct
callback is made with the result of the RPC call. Eventually, the run time would construct a json-rpc object that looks
like this:

{
  "jsonrpc"    : "2.0",
  "method"     : "sum",
  "id"         : 123,
  "parameters" : numbers    /* the original array of numbers we passed in from the stub */
}

This JSON object is passed to the JSONRPC layer before being sent through the transport. The job of the JSONRPC layer (3)
here (i.e. when the call is being made as opposed to received) is to verify that the object being sent actually matches
the JSON-RPC spec before being sent. If it is validated successfully, it is passed to the transport layer.

The transport layer (4) loads the module, and uses the module's postMessage method to finally post the message to the
actual C++ native client module (5).

The C++ code gets executed, a result is made on the C++ side, and is sent back to the javascript code using the pepper
api with postMessage. The message that is sent is again a JSON-RPC object, that would look something like this:

{
  "jsonrpc" : "2.0",
  "result"  : 7789.32123,
  "id"      : 123
}


The postMessage is handled in JavaScript by the NaClModule, and passed to the Transport layer. It is then passed to the
JSONRPC layer, where it identifies whether it is a callback, a call, or an error. If it is a callback, the handle
callback method of the RPC Runtime is called with the result. Here, the runtime figures out which callback to call using
the id. The callback is finally called with the result and the RPC is concluded.

A similar process is done when the C++ code wishes to make a Javascript remote procedure call. The difference is that
this time, the JSONRPC layer identifies that this is a call as opposed to a response. The method is looked up in the
RPC Runtime. If it is found, it is executed. Any errors thrown are sent back to the caller using the JSON-RPC error
format. If no errors are made, a response is made using the runtime, and sent in a similar way to how a request was sent
as explained above.